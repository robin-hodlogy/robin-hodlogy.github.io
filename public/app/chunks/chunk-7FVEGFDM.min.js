import{a as y,i as ne}from"https://app.gitbook.com/public/app/chunks/chunk-666XU7Q6.min.js";import{hb as b,u as ee,v as T,x as te,y as B}from"https://app.gitbook.com/public/app/chunks/chunk-RFZIPQ3K.min.js";import{$a as v,Ba as j,Ea as _,Ga as J,Ia as E,L as R,La as Y,M as Q,N as D,P as k,Ra as H,Sa as X,Ta as Z,Wa as K,Xb as x,wa as F,ya as W}from"https://app.gitbook.com/public/app/chunks/chunk-E7KOX4IY.min.js";import{Ra as M,Wa as L,_a as $,a as m,ab as V,cb as O,ib as U,jb as q,kb as G,lb as C,mb as N}from"https://app.gitbook.com/public/app/chunks/chunk-EFJ6CI7R.min.js";import{a as g}from"https://app.gitbook.com/public/app/chunks/chunk-HCFMPDL2.min.js";import{a as h}from"https://app.gitbook.com/public/app/chunks/chunk-XQJO7322.min.js";import{k as Buffer,l as f}from"https://app.gitbook.com/public/app/chunks/chunk-OAKVUAEN.min.js";f();f();async function ie(e,t={}){let n=new C(t.reader),r;if(e.changeRequestKey){let o=y(e.spaceKey,e.changeRequestKey);r=(await n.assertDocument(o)).revisionCurrent}else{let o=v(e.spaceKey);r=(await n.assertDocument(o)).revision}return await K(e.spaceKey,r,{reader:n})}f();f();var re=h("documents");function ve(e){let t=e.change().normalizeDocument();if(t.operations.size>0){let n=new Error("serializing document with normalization");M(n)}return t.value}function oe(e,t){let n=ee.isValue(e)?e:b(e,t),r=ve(n),i=te(r.document,{preserveKeys:!0});return i.length>1*1024*1024?re.warning(`document is larger than 1MB (${(i.length/1024).toFixed(0)}KB), too big for one single Firestore document.`):i.length>512*1024&&re.warning(`document is larger than 512KB (${(i.length/1024).toFixed(0)}KB), might become too big for one Firestore document`),m.firestore.Blob.fromUint8Array(i)}function je(e,t="document"){let n;return typeof e=="string"?n=T(JSON.parse(e)):e instanceof m.firestore.Blob?n=B(e.toUint8Array()):typeof Buffer<"u"&&Buffer.isBuffer(e)?n=B(e):n=T(e),n=n.fixDuplicatedKeys(),b(n,t)}function se(e){return typeof e=="string"||e instanceof m.firestore.Blob}var ae=900*1024;function ye(e){return v(e).collection("sheets")}function P(e,t){return ye(e).doc(t)}function A(e,t){return P(e,t).collection("chunks")}function ke(e,t,n){return A(e,t).doc(n)}function ot(e){return{key:g(),body:se(e.document)?e.document:oe(b(e.document)),edits:R(e.users),revision:e.revision,page:e.page}}function st(e,t,n){let{sheet:r,chunks:i}=Oe(n);e.set(P(t,r.key),r),i.forEach(o=>e.set(ke(t,r.key,o.key),o))}async function be(e,t,n={}){let{strategy:r="optimistic"}=n,i=new C(n.reader),[o,s]=await(async()=>{var a;if(r==="optimistic"){let c=await i.getDocument(P(e,t));return c?((a=c.chunks)==null?void 0:a.length)===0?[c,[]]:Promise.all([c,i.getCollection(A(e,t))]):[void 0,[]]}return Promise.all([i.getDocument(P(e,t)),i.getCollection(A(e,t))])})();return o?Ce({sheet:o,chunks:s}):null}async function at(e,t,n={}){let r=await be(e,t,n);if(!r)throw new Error(`Sheet ${t} not found in space ${e}`);return r}function Oe(e){if(typeof e.body=="string")return{sheet:e,chunks:[]};let t=e.body.toUint8Array();if(t.length<=ae)return{sheet:e,chunks:[]};let[n,...r]=xe(t,ae),i=r.map(s=>({key:g(),body:m.firestore.Blob.fromUint8Array(s)}));return{sheet:{...e,chunks:i.map(s=>s.key),body:m.firestore.Blob.fromUint8Array(n)},chunks:i}}var ce=new WeakMap;function Ce(e){let{sheet:t,chunks:n}=e,r=t.chunks;if(typeof t.body=="string"||!r||r.length===0)return t;let i=ce.get(t);if(i)return i;let o=r.map(d=>{let l=n.find(Re=>Re.key===d);if(!l)throw new Error(`Chunk ${d} not found for sheet "${t.key}"`);return l.body.toUint8Array()})||[],s=[t.body.toUint8Array(),...o],a=s.reduce((d,l)=>d+l.length,0),c=new Uint8Array(a),p=0;s.forEach(d=>{c.set(d,p),p+=d.length});let u={...t,chunks:void 0,body:m.firestore.Blob.fromUint8Array(c)};return ce.set(t,u),u}function xe(e,t){let n=[];for(let r=0;r<e.length;r+=t)n.push(e.slice(r,r+t));return n}f();function dt(e,t={}){return{edits:typeof t=="string"?R([t]):t,...e,key:e.key||g()}}function ue(e,t){return{...e,edits:Q(e.edits,t)}}f();var Pe=h("database:revisions"),S={markAsModified:!0};async function I(e,t,n,r,i={}){let{edits:o}=i;if("chunks"in n)throw new Error("Cannot commit updates to a revision with chunks. Make sure to pass a Revision and not a ChunkedRevision.");let s;if(o)s=o;else{let c=$();if(!c)throw new Error("Cannot commit updates without a current user");s=R([c])}if(e!==n.space)throw new Error("commitRevisionUpdates has been called with an inconsistent spaceKey");function a(c){let p=m.firestore.Timestamp.now(),u=n.conflicts?G(n):_(n,{edits:s});u.changeRequest=t,u.key!==n.key&&!u.changeRequest&&(u.activeAt=p),r(u,c),u.key===n.key&&J(u);let d=Z(u);if(c.set(H(u.space,u.key),d.revision),d.chunks.forEach(l=>c.set(X(u.space,u.key,l.key),l)),u.key!==n.key)if(u.changeRequest){let l=y(u.space,u.changeRequest);c.update(l,{revisionCurrent:u.key,updatedAt:p}),D(c,l,"edits",s)}else{let l=v(u.space);c.update(l,{revision:u.key}),D(c,l,"edits",s)}return u}return i.transaction?a(i.transaction):U(a)}async function fe(e,t,n,r,i={}){let o=new L("revisions.commitLinearRevisionUpdates"),{transactionRunner:s}=i;return o.label("space",n.space),o.label("changeRequest",t),o.label("baseRevision",n.key),await o.wrap(async()=>{try{return await(s?s(c=>I(e,t,n,r,{...i,transaction:c})):I(e,t,n,r,i))}catch(a){if(V(a))return o.label("didAutoRetry",!0),await O(async c=>{let p=await ie({spaceKey:e,changeRequestKey:t},{reader:new N(c)});return Pe.debug(`retrying linear revision updates after permissions denied with base ${p.key}`),await I(e,t,p,r,{...i,transaction:c})});throw a}})}function pe(e,t,n,r,i=S){let o=k(e.edits);e.pages[n.key]=i.markAsModified&&o?F(n,o.user):n;let s=t?e.pages[t]:void 0;if((s==null?void 0:s.kind)==="link")throw new Error("Cannot insert page in link");let a=s?s.pages:e.rootPages;typeof r=="number"?a.splice(r,0,n.key):a.push(n.key)}function Se(e,t,n,r=S){let i=E(e,n),o=(i?i.pages:e.rootPages).indexOf(n);if(!(o<0))return pe(e,i?i.key:void 0,t,o+1,r)}function z(e,t,n,r=S){let i=e.pages[t];if(!i)return;let o=typeof n=="function"?n(i):{...i,...n};if(e.pages[t]=o,r.markAsModified){let s=k(e.edits);s&&(e.pages[t]=F(o,s.user))}}function Et(e,t,n){z(e,t,n?{cover:n,coverY:0}:{coverY:0})}function Tt(e,t){z(e,t,n=>("coverY"in n&&(delete n.cover,delete n.coverY),{...n}))}function we(e,t,n={}){let r=e.pages[t];if(!r)return;let i=E(e,t);if(n.deleteEmptyGroupParent&&i&&i.kind==="group"&&i.pages.length===1)return we(e,i.key);let o=[r.key];r.kind!=="link"&&Y(e,t).forEach(c=>{o.push(c.key)}),Object.values(e.pages).some(a=>a.kind==="sheet"&&!o.includes(a.key))&&(i?i.pages=i.pages.filter(a=>a!==t):e.rootPages=e.rootPages.filter(a=>a!==t),o.forEach(a=>{var c,p;delete e.pages[a],(c=e.conflicts)!=null&&c.pages[a]&&((p=e.conflicts)==null||delete p.pages[a])}),de(e))}function Bt(e,t,n,r=S){let i=e.files[t];if(!i)return;let o=typeof n=="function"?n(i):{...i,...n};if(e.files[t]=o,r.markAsModified){let s=k(e.edits);s&&(e.files[t]=ue(e.files[t],s.user))}}function At(e,t){if(e.files[t.key])throw new Error("File already existing in revision");e.files[t.key]=t}function Ue(e,t,n){e.conflicts&&t in e.conflicts.pages&&(e.conflicts.pages[t]=n),de(e)}function de(e){j(e)&&Object.values(e.conflicts.pages).some(n=>n)||delete e.conflicts}function It(e,t){Ue(e,t,!1)}function De(e,t){let{originalPageKey:n,parentPageKey:r}=t,i=t.newKey||g(),o=e.pages[n],s=k(e.edits);if(!s)throw new Error("Trying to duplicate a page with no contributions, error");let a=W(o,{pageKey:i,user:s.user,rename:!r});r?pe(e,r,a):Se(e,a,n);let c;return(o.kind==="group"||o.kind==="sheet")&&(c=o.pages.map((p,u)=>{let d=g();return De(e,{originalPageKey:p,parentPageKey:a.key,newKey:d}),d})),z(e,a.key,{pages:c}),e}f();var w=class{constructor(t,n){this.currentOperation=null;this.pending=[];this.executeOperation=t,this.mergeOperations=n}async execute(t){let n=new Promise((r,i)=>{this.pushOperation({operation:t,resolve:r,reject:i})});return await this.resume(),n}async resume(){if(this.currentOperation)return this.currentOperation;let t=this.pending.shift();if(!t)return;let n;try{this.currentOperation=this.executeOperation(t.operation),n=await this.currentOperation,t.resolve(n)}catch(r){t.reject(r)}finally{this.currentOperation=null,this.pending.length>0&&(n=await this.resume())}return n}async waitOnCurrentOperation(){let t;return this.currentOperation&&(t=await this.currentOperation),this.pending.length===0&&!this.currentOperation?t:this.resume()}pushOperation(t){if(this.pending.length===0||!this.mergeOperations){this.pending.push(t);return}let n=this.pending.pop(),r=this.mergeOperations(n.operation,t.operation);this.pending.push({operation:r,resolve:i=>{try{n.resolve(i)}finally{t.resolve(i)}},reject:i=>{try{n.reject(i)}finally{t.reject(i)}}})}};f();var le=(e,t)=>{x.write(e,t,"cached")};function Wt(e){return q(t=>(t.listenToDocument(le),e(t)))}function me(e){return O(t=>(t.listenToDocument(le),e(t)))}var ge=h("space:revision"),he=new Map;function tn(e,t,n){return Fe(e,t).execute(n)}function Fe(e,t=void 0){let n=Ee(e,t),r=he.get(n);return r||(r=new w(i=>Te(e,t,i),(i,o)=>(s,a)=>{i(s,a),o(s,a)}),he.set(n,r)),r}function Ee(e,t=void 0){return`${e}/${t||""}`}async function Te(e,t,n){let r=await ne({spaceKey:e,changeRequestKey:t});ge.info(`start update on "spaces/${r.space}/revisions/${r.key}"`);let i=0,o=await fe(e,t||null,r,(s,a)=>{i+=1,ge.info(`iterate (#${i}) update on "spaces/${r.space}/revisions/${s.key}" (base: ${r.key})`),n(s,a)},{transactionRunner:me});return t&&x.clear(y(e,t)),o}export{ve as a,je as b,P as c,ke as d,ot as e,st as f,at as g,Ce as h,dt as i,pe as j,z as k,Et as l,Tt as m,we as n,Bt as o,At as p,It as q,De as r,Wt as s,tn as t};
//# sourceMappingURL=https://app.gitbook.com/public/app/chunks/chunk-7FVEGFDM.min.js.map
